HAL_COMP(genpp3); // Generate pulse pattern (3-phase)

//sdu sdv sdw input
HAL_PIN(sdu) = 0.0;
HAL_PIN(sdv) = 0.0;
HAL_PIN(sdw) = 0.0;

//modulation mode
HAL_PIN(mode) = 2.0;
// Number of pulse-periods in the next FRT-Cycle for each channel
HAL_PIN(periods) = 1.0;

//HAL_PIN(hv_temp) = 0.0;

//enable in
HAL_PIN(enable) = 0.0;
//TODO: half bridge enable in
HAL_PIN(enu) = 1.0;
HAL_PIN(env) = 1.0;
HAL_PIN(enw) = 1.0;

//fault output
HAL_PIN(fault) = 0.0;

HAL_PIN(min_on_pwm) = 20.0;		// min on-time [pwm-systicks] - Genügt das zum Messen? Ggf. anpassen!
HAL_PIN(min_off_pwm) = 40.0; 	//min off-time [pwm-systicks]

MEMEXT(uint16_t next_ADC_FRT_PERIOD_CYCLES); // Defined in pwmadcdma.c
MEMEXT(uint16_t actual_ADC_FRT_PERIOD_CYCLES);
// TODO: Gedanke: ch_timer_buffer und ch_GPIOs_buffer sind wahrscheinlich am Besten für die Auswertung?? Dann 3*PWM_DMA_MAX_EDGES lang machen und Ringpuffern
MEMEXT(uint32_t ch_timer_buffer[N_PWM_CHANNELS][N_PWM_MAX_EDGES]); // Ein Array fuer jeden Channel. N_PWM_CHANNELS=3
MEMEXT(uint16_t ch_GPIOs_buffer[N_PWM_MAX_EDGES]);
MEM(uint16_t const_PIN_MASK[3]); // TODO: in pwmadcdma.c definieren
MEM(int en) = 0;

FRT(
//   float udc = MAX(PIN(udc), 0.1);
//TODO:!
//PIN_MASK = transpose(uint16(zeros(length(PIN_IDs),1)));
//for i = 1:length(PIN_IDs)
//  PIN_MASK(i) = uint16( bitshift(uint16(1), uint16(PIN_IDs(i))) );
//endfor
   const_PIN_MASK[0] = 1<<1;
   const_PIN_MASK[1] = 1<<2;
   const_PIN_MASK[2] = 1<<3;
   // next_ADC_FRT_PERIOD_CYCLES wurde ggf vorher neu berechnet.
   uint16_t next_PWM_FRT_PERIOD_CYCLES = next_ADC_FRT_PERIOD_CYCLES * ADC_PWM_DIVIDER;
   uint16_t actual_PWM_FRT_PERIOD_CYCLES = actual_ADC_FRT_PERIOD_CYCLES * ADC_PWM_DIVIDER;

   int16_t periods = (int16_t)PIN(periods);
   int16_t sp_period = next_PWM_FRT_PERIOD_CYCLES / periods; // Periode eines Single Pulse. TODO: Beachte nicht-ganzzahlige Division

   // Wertebereich zurechstutzen
   uint16_t p[3];
   p[0] = CLAMP(PIN(sdu), 0.0, 1.0) * sp_period;
   p[1] = CLAMP(PIN(sdv), 0.0, 1.0) * sp_period;
   p[2] = CLAMP(PIN(sdw), 0.0, 1.0) * sp_period;

   // Mindestschaltzeiten sicherstellen
   uint16_t min_on_pwm = PIN(min_on_pwm);
   uint16_t min_off_pwm = PIN(min_off_pwm);
   if((p[0] > 0 && p[0] < min_on_pwm) || (p[1] > 0 && p[1] < min_on_pwm) || (p[2] > 0 && p[2] < min_on_pwm)){
	  p[0] += min_on_pwm;
	  p[1] += min_on_pwm;
      p[2] += min_on_pwm;
   }

   if((p[0] > sp_period - min_off_pwm) || (p[1] > sp_period - min_off_pwm) || (p[2] > sp_period - min_off_pwm)){
	  p[0] -= min_off_pwm;
	  p[1] -= min_off_pwm;
	  p[2] -= min_off_pwm;
   }


   uint16_t pcnt[3]; // Anzahl der neuen Pulse in einer Phase
   pcnt[0]=0; pcnt[1]=0; pcnt[2]=0;
   uint16_t pstate = 0;

   // TODO Achtung: hier muss jeweils noch die letzte Off-Zeit aus dem letzten FRT-Zyklus berücksichtigt werden
   //   Besser genau zum Ende des
   // TODO Je nach Pulsmuster kann ein GPIO aus dem letzten FRT-Zyklus auch noch eingeschaltet sein.

   // switch-case mode 0 % center aligned PWM  --> TODO: Machen!

   uint32_t center = 0; // ACHTUNG: möglichst Rundungsfehler vermeiden.

   uint16_t periods2 = 2 * periods;
   uint16_t i; uint16_t ip;
   for(i = 1; i < periods2; i += 2) {
	   center = i * next_PWM_FRT_PERIOD_CYCLES / periods2;
	   for(ip = 0; ip < 3; ip++) {
		   if(p[ip] > 0) {
			   ch_timer_buffer[ip][i]	=	center - p[i]; 		// Einschaltpuls
			   ch_GPIOs_buffer[i]		|=	const_PIN_MASK[ip];
			   ch_timer_buffer[ip][i+1]	=	center + p[i]; 		// Ausschaltpuls
			   ch_GPIOs_buffer[i+1]		&=	~const_PIN_MASK[ip];
			   pcnt[ip] += 2;
		   }
	   }
   }

   // ch_timer_buffer immer 0xFFFF-terminieren weil so das Sortieren schneller geht.
   for(ip = 0; ip < 3; ip++) {
	   ch_timer_buffer[ip][pcnt[ip]] = (uint32_t)0xFFFF;
   }

   //TODO: check enable timing on fault pin
   PIN(fault) = 0;//HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_7);
);

RT(
  en = (int)PIN(enable);
);

ENDCOMP;
